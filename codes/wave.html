<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="description" />
<meta name="keywords" content="keywords" />
<meta name="author" content="author" />
<link rel="stylesheet" type="text/css" href="pagestyle.css" />
<title>Arman Akbarian's Homepage</title>
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>
<div class="page">
  <div class="page2">
     <div style="width:100%;height:1px;font-family: Tahoma; font-size: 1pt;"></div>
     <div  class ="header">
		
	     <div class="title">

			Arman Akbarian
			<div class="subtitle">UNIVERSITY OF BRITISH COLUMBIA <br /> PHYSICS &amp; ASTRONOMY DEPT. </div>
	</div> <!-- End of title -->
		<div class="sidebar">
         	<div class="sider">
               <p><a href="Home.html">Home <img src="img/home.svg" width="11px" /></a>
<a href="Research.html">Research <img src="img/beaker.svg" width="11px" /></a>
<a href="Publications.html">Publications <img src="img/pencil.svg" width="11px" /></a>
<a target="_blank" href="http://laplace.phas.ubc.ca/">Group Page <img style="margin-left:1px;" src="img/external-link.svg" alt="" align="bottom" /> <img src="img/people.svg" width="11px" /></a>
<a href="Contact.html">Contact <img src="img/envelope-closed.svg" width="11px" /></a>
<a href="CV.html">CV <img src="img/person.svg" width="11px" /></a></p>

<hr />

<p><a href="Links.html">Links <img src="img/link.svg" width="11px" /></a>
<a href="Learn-By-Examples.html">Programming <img src="img/code.svg" width="11px"/></a>
<a target="_blank" href="FD_doc">FD Toolkit <img style="margin-left:1px;" src="img/external-link.svg" alt="" align="bottom" /> <img src="img/graph.svg" width="11px" /></a>
<a target="_blank" href="sg">Web Template <img style="margin-left:1px;" src="img/external-link.svg" alt="" align="bottom" /> <img src="img/globe.svg" width="11px" /></a>
<a href="http://rmanak.github.io/notes">Miscellany <img src="img/layers.svg" width="11px" /></a></p>

             </div>
         </div> <!--End of Sidebar -->


     </div> <!-- end header -->
	
     <!--This line is for future use -->   <div style="text-align:center; padding-top:10px; padding-bottom:10px;"></div>
	      
     <!--This line is for compatibility issues --> <div style="width:100%;height:5px;font-family: Tahoma; font-size: 1pt;"></div>
     <!--in class page2 -->
     <div class="postandside">
		        <div class="content">
            <div class="post">
              <pre>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// application interface functions for wave example</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// PAMR example to solve 2D wave equation</span>
<span style='color:#898887;'>// See http://laplace.physics.ubc.ca/People/arman/file/wave2d_pamr.tar.gz for source</span>

<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;stdlib.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;stdio.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;pamr.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;amrd.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;math.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;mpi.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&quot;wave.h&quot;</span>

<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;sys/timeb.h&gt;</span>
<span style='color:#0057ae;'>void</span> elapsed_time(<span style='color:#0057ae;'>void</span>);

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// id parameters (time symmetric gaussian)</span>
<span style='color:#898887;'>//=============================================================================</span>

<span style='color:#898887;'>//Initialization parameters:</span>
real amp, tdam, xc, xwid, yc, ywid;
<span style='color:#898887;'>//=====================================</span>

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// some convenient, &quot;local&quot; global variables</span>
<span style='color:#898887;'>//=============================================================================</span>

<span style='color:#898887;'>//The pointers to actual grid function data:</span>
real *f_t_n, *f_t_np1, *f_n, *f_np1;
<span style='color:#898887;'>//=======================================</span>

<span style='color:#898887;'>//The pointers to grid:</span>
real *x, *y;
<span style='color:#898887;'>//===========================</span>

<span style='color:#898887;'>//Parameters that describe the grid:</span>
<span style='color:#0057ae;'>int</span> shape[<span style='color:#b08000;'>2</span>]; <span style='color:#898887;'>// number of grid points in each dim, basically shape[0]=Nx, shape[1]=Ny</span>
<span style='color:#0057ae;'>int</span> ghost_width[<span style='color:#b08000;'>4</span>]; <span style='color:#898887;'>//side of ghost cells, 2*dim array, at x_min, x_max, y_min and so on</span>
<span style='color:#0057ae;'>int</span> Nx,Ny;
<span style='color:#0057ae;'>int</span> phys_bdy[<span style='color:#b08000;'>4</span>]; <span style='color:#898887;'>// 1 or 0, wether or not boundary is physical, has size = dim*2</span>
<span style='color:#0057ae;'>int</span> lb_flag,rb_flag,tb_flag,bb_flag; <span style='color:#898887;'>//convenient variable for phys boundary indication</span>
<span style='color:#0057ae;'>int</span> size; <span style='color:#898887;'>//size=Nx*Ny*...</span>
<span style='color:#0057ae;'>int</span> dim; <span style='color:#898887;'>//the spatial dimension of the grid (only 1,2 or 3)</span>
<span style='color:#0057ae;'>int</span> g_rank; <span style='color:#898887;'>// To store the MPI rank of the execution</span>

real base_bbox[<span style='color:#b08000;'>4</span>], bbox[<span style='color:#b08000;'>4</span>], dx, dy, dt; 
<span style='color:#898887;'>// bbox stores the coordinate bounding box [x1,x2,y1...]</span>
<span style='color:#898887;'>// base_bbox is the coordinate of the entire domain</span>
<span style='color:#0057ae;'>int</span> g_L; <span style='color:#898887;'>//to store the grid level (in AMR heirarchy)</span>


<span style='color:#898887;'>//To store the grid function numbers, see set_gfns subroutine</span>
<span style='color:#0057ae;'>int</span> f_t_n_gfn, f_t_np1_gfn, f_n_gfn, f_np1_gfn;
<span style='color:#898887;'>//===========</span>


<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// call after variables have been defined</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> set_gfns(<span style='color:#0057ae;'>void</span>)
{
      <b>if</b> ((f_t_np1_gfn = PAMR_get_gfn(<span style='color:#bf0303;'>&quot;f_t&quot;</span>,PAMR_AMRH,<span style='color:#b08000;'>1</span>))&lt;<span style='color:#b08000;'>0</span>) AMRD_stop(<span style='color:#bf0303;'>&quot;set_gnfs error&quot;</span>,<span style='color:#b08000;'>0</span>);
      <b>if</b> ((f_t_n_gfn   = PAMR_get_gfn(<span style='color:#bf0303;'>&quot;f_t&quot;</span>,PAMR_AMRH,<span style='color:#b08000;'>2</span>))&lt;<span style='color:#b08000;'>0</span>) AMRD_stop(<span style='color:#bf0303;'>&quot;set_gnfs error&quot;</span>,<span style='color:#b08000;'>0</span>);

      <b>if</b> ((f_np1_gfn   = PAMR_get_gfn(<span style='color:#bf0303;'>&quot;f&quot;</span>,PAMR_AMRH,<span style='color:#b08000;'>1</span>))&lt;<span style='color:#b08000;'>0</span>) AMRD_stop(<span style='color:#bf0303;'>&quot;set_gnfs error&quot;</span>,<span style='color:#b08000;'>0</span>);
      <b>if</b> ((f_n_gfn     = PAMR_get_gfn(<span style='color:#bf0303;'>&quot;f&quot;</span>,PAMR_AMRH,<span style='color:#b08000;'>2</span>))&lt;<span style='color:#b08000;'>0</span>) AMRD_stop(<span style='color:#bf0303;'>&quot;set_gnfs error&quot;</span>,<span style='color:#b08000;'>0</span>);

<span style='color:#898887;'>// get_gfn returns the grid function number:</span>
<span style='color:#898887;'>// PAMR_get_gfn(A,B,C) </span>
<span style='color:#898887;'>// A &gt;&gt; grid function name</span>
<span style='color:#898887;'>// B &gt;&gt; in which heirarchy, two options: PAMR_AMRH: AMR heirarchy, PAMR_MGH: multigrid h.</span>
<span style='color:#898887;'>// C &gt;&gt; time level if it is in AMRH, else 0, latest time ordered first.</span>
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// call with valid iter to set up globals:</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> ldptr(<span style='color:#0057ae;'>void</span>) 
{
     real dx0[<span style='color:#b08000;'>2</span>];
     real *x0[<span style='color:#b08000;'>2</span>]; <span style='color:#898887;'>//array of size dim, pointing to local perimeter coordinate array</span>
     real *gfs[PAMR_MAX_GFNS]; <span style='color:#898887;'>//array of size ngfs, pointers to local data array</span>
   <span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> first=<span style='color:#b08000;'>1</span>;

   <b>if</b> (first) 
   {
      first=<span style='color:#b08000;'>0</span>; 
      set_gfns();
      PAMR_get_global_bbox(base_bbox); <span style='color:#898887;'>//AAK??</span>
   }
<span style='color:#898887;'>//These are to get the information of the grid</span>
   PAMR_get_g_dim(&amp;dim); <span style='color:#898887;'>//saves the dimension of the grid in dim</span>
   PAMR_get_g_rank(&amp;g_rank); <span style='color:#898887;'>// gets the MPI rank</span>
   PAMR_get_g_shape(shape); <span style='color:#898887;'>//gets the shape (Nx,Ny...)</span>
   PAMR_get_g_bbox(bbox); <span style='color:#898887;'>//gets the boundary (x1,x2,y1,y2...)</span>
   PAMR_get_g_ghost_width(ghost_width); <span style='color:#898887;'>//gets the ghots width at boundaries</span>
   PAMR_get_g_level(&amp;g_L); <span style='color:#898887;'>// gets the level number of the current grid</span>
   PAMR_get_dxdt(g_L,dx0,&amp;dt); <span style='color:#898887;'>//clear</span>
   dx=dx0[<span style='color:#b08000;'>0</span>]; <span style='color:#898887;'>//convenient variables??</span>
   dy=dx0[<span style='color:#b08000;'>1</span>];

<span style='color:#898887;'>//AAK: This is for finding the real boundary</span>
   <b>if</b> ((bbox[<span style='color:#b08000;'>0</span>]-base_bbox[<span style='color:#b08000;'>0</span>])&lt;dx/<span style='color:#b08000;'>2</span>) phys_bdy[<span style='color:#b08000;'>0</span>]=<span style='color:#b08000;'>1</span>; <b>else</b> phys_bdy[<span style='color:#b08000;'>0</span>]=<span style='color:#b08000;'>0</span>;
   <b>if</b> ((base_bbox[<span style='color:#b08000;'>1</span>]-bbox[<span style='color:#b08000;'>1</span>])&lt;dx/<span style='color:#b08000;'>2</span>) phys_bdy[<span style='color:#b08000;'>1</span>]=<span style='color:#b08000;'>1</span>; <b>else</b> phys_bdy[<span style='color:#b08000;'>1</span>]=<span style='color:#b08000;'>0</span>;
   Nx=shape[<span style='color:#b08000;'>0</span>];

   <b>if</b> ((bbox[<span style='color:#b08000;'>2</span>]-base_bbox[<span style='color:#b08000;'>2</span>])&lt;dy/<span style='color:#b08000;'>2</span>) phys_bdy[<span style='color:#b08000;'>2</span>]=<span style='color:#b08000;'>1</span>; <b>else</b> phys_bdy[<span style='color:#b08000;'>2</span>]=<span style='color:#b08000;'>0</span>;
      <b>if</b> ((base_bbox[<span style='color:#b08000;'>3</span>]-bbox[<span style='color:#b08000;'>3</span>])&lt;dy/<span style='color:#b08000;'>2</span>) phys_bdy[<span style='color:#b08000;'>3</span>]=<span style='color:#b08000;'>1</span>; <b>else</b> phys_bdy[<span style='color:#b08000;'>3</span>]=<span style='color:#b08000;'>0</span>;
      Ny=shape[<span style='color:#b08000;'>1</span>];
      size=Nx*Ny;

   <span style='color:#898887;'>//setting the convenient variables</span>
   lb_flag = phys_bdy[<span style='color:#b08000;'>0</span>];
   rb_flag = phys_bdy[<span style='color:#b08000;'>1</span>];
   bb_flag = phys_bdy[<span style='color:#b08000;'>2</span>];
   tb_flag = phys_bdy[<span style='color:#b08000;'>3</span>];
<span style='color:#898887;'>//=========================</span>
   PAMR_get_g_x(x0); <span style='color:#898887;'>//gets the pointer to the coordinate array</span>

   x=x0[<span style='color:#b08000;'>0</span>]; <span style='color:#898887;'>//the pointers to the array of actual grid data (size Nx*Ny..)</span>
   y=x0[<span style='color:#b08000;'>1</span>]; 

   PAMR_get_g_gfs(gfs); <span style='color:#898887;'>//gets the pointer to local data of grid function</span>

     <span style='color:#898887;'>//AAK:store the pointer in convenient variables</span>
     f_n     = gfs[f_n_gfn-<span style='color:#b08000;'>1</span>]; <span style='color:#898887;'>//AAK?? what is -1, numbering starts from  1?</span>
     f_np1   = gfs[f_np1_gfn-<span style='color:#b08000;'>1</span>];
     f_t_n   = gfs[f_t_n_gfn-<span style='color:#b08000;'>1</span>];
     f_t_np1 = gfs[f_t_np1_gfn-<span style='color:#b08000;'>1</span>];

}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// utility routines</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> const_f(real *f, real c)
{
   <span style='color:#0057ae;'>int</span> i;

     <b>for</b> (i=<span style='color:#b08000;'>0</span>; i&lt;Nx*Ny; i++) f[i]=c;
}

<span style='color:#0057ae;'>void</span> zero(real *f)
{
   const_f(f,<span style='color:#b08000;'>0</span>);
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Routines required by amrd:</span>
<span style='color:#898887;'>//=============================================================================</span>

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Returns 0 to use default mechanism, or is expected to calculate</span>
<span style='color:#898887;'>// the correct initial hierarchy and return 1:</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>int</span> wave_id(<span style='color:#0057ae;'>void</span>) 
{
	<b>if</b>( my_rank == <span style='color:#b08000;'>0</span> ) elapsed_time();
   <b>return</b> <span style='color:#b08000;'>0</span>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Sets custom parameters, variables, etc. Split up into two segments,</span>
<span style='color:#898887;'>// one called before the pamr context is initialized and standard</span>
<span style='color:#898887;'>// parameters are read, and the other afterwards</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_var_pre_init(<span style='color:#0057ae;'>char</span> *pfile)
{
   <b>return</b>;
}


<span style='color:#898887;'>//AAK: one of the hook functions passed to amrd, to read the parameters from file</span>
<span style='color:#0057ae;'>void</span> wave_var_post_init(<span style='color:#0057ae;'>char</span> *pfile)
{
   <span style='color:#0057ae;'>int</span> i,j;
   <span style='color:#0057ae;'>char</span> buf[<span style='color:#b08000;'>64</span>]; <span style='color:#898887;'>//AAK??</span>

   <b>if</b> (my_rank==<span style='color:#b08000;'>0</span>)
   {
		system(<span style='color:#bf0303;'>&quot;date &gt; date.dat&quot;</span>);
      printf(<span style='color:#bf0303;'>&quot;===================================================================</span><span style='color:#924c9d;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
      printf(<span style='color:#bf0303;'>&quot;Reading wave parameters:</span><span style='color:#924c9d;'>\n\n</span><span style='color:#bf0303;'>&quot;</span>);
   }

   
     amp=tdam=xc=yc=<span style='color:#b08000;'>0</span>;
     xwid=ywid=<span style='color:#b08000;'>1</span>;
     <span style='color:#898887;'>//AAK: the file is in RNPL format</span>
     <span style='color:#898887;'>// last argument is the size of the array, 1 for just a real number</span>
   AMRD_real_param(pfile,<span style='color:#bf0303;'>&quot;amp&quot;</span>,&amp;amp,<span style='color:#b08000;'>1</span>);
   AMRD_real_param(pfile,<span style='color:#bf0303;'>&quot;tdam&quot;</span>,&amp;tdam,<span style='color:#b08000;'>1</span>);
   AMRD_real_param(pfile,<span style='color:#bf0303;'>&quot;xc&quot;</span>,&amp;xc,<span style='color:#b08000;'>1</span>);
   AMRD_real_param(pfile,<span style='color:#bf0303;'>&quot;yc&quot;</span>,&amp;yc,<span style='color:#b08000;'>1</span>);
   AMRD_real_param(pfile,<span style='color:#bf0303;'>&quot;xwid&quot;</span>,&amp;xwid,<span style='color:#b08000;'>1</span>);
   AMRD_real_param(pfile,<span style='color:#bf0303;'>&quot;ywid&quot;</span>,&amp;ywid,<span style='color:#b08000;'>1</span>);
   

   <b>if</b> (my_rank==<span style='color:#b08000;'>0</span>) printf(<span style='color:#bf0303;'>&quot;===================================================================</span><span style='color:#924c9d;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
   <b>return</b>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Sets all t=n variables to their 'zero' values:</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_AMRH_var_clear(<span style='color:#0057ae;'>void</span>)
{
    ldptr();

<span style='color:#898887;'>//   zero(phi_n); </span>

     zero(f_n);
     zero(f_t_n);
   <b>return</b>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Initial data for free fields: (at tn=2)</span>
<span style='color:#898887;'>//</span>
<span style='color:#898887;'>// currently, we only allow for time-symmetric initial data</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_free_data(<span style='color:#0057ae;'>void</span>)
{
   ldptr();
<span style='color:#898887;'>//This initializes the grid, all the calculations are encapsulated in the routine.</span>
     initializer0_(f_t_n,f_n,&amp;Nx,&amp;Ny,x,y,&amp;amp,&amp;tdam,&amp;xc,&amp;xwid,&amp;yc,&amp;ywid);


   <b>return</b>;
}  

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Initial constraint data --- called after each MG iteration.</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_t0_cnst_data(<span style='color:#0057ae;'>void</span>)
{
   <b>return</b>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Calculations prior to saving info to disk.</span>
<span style='color:#898887;'>//</span>
<span style='color:#898887;'>// </span><b><span style='color:#81ca2d;background:#f7e6e6;'>NOTE</span></b><span style='color:#898887;'>: at this point, the time sequence is: n,nm1,np1</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_pre_io_calc(<span style='color:#0057ae;'>void</span>)
{
   <b>return</b>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Returns some norm of the residual for the evolution variables,</span>
<span style='color:#898887;'>// called after an evolution iteration.</span>
<span style='color:#898887;'>// We're using an explicit scheme to solve for phi, hence return 0</span>
<span style='color:#898887;'>//=============================================================================</span>
real wave_evo_residual(<span style='color:#0057ae;'>void</span>)
{
   <b>return</b> <span style='color:#b08000;'>0</span>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Returns some norm of the residual for the MG variables, *AND* </span>
<span style='color:#898887;'>// stores the point-wise residual in &quot;f_res&quot; for each MG variable &quot;f&quot; (for</span>
<span style='color:#898887;'>// computing new RHS's)</span>
<span style='color:#898887;'>//=============================================================================</span>
real wave_MG_residual(<span style='color:#0057ae;'>void</span>)
{
   <b>return</b> <span style='color:#b08000;'>0</span>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Performs 1 iteration of the evolution equations </span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_evolve(<span style='color:#0057ae;'>int</span> iter)
{
   ldptr();
<span style='color:#898887;'>//This updates the grid, all the calculations are encapsulated in the routine</span>
<span style='color:#006e28;'>#ifdef</span><span style='color:#006e28;'> __L </span>
    update0__(f_t_np1,f_t_n,f_np1,f_n,&amp;Nx,&amp;Ny,&amp;dt,&amp;dx,&amp;dy,&amp;bb_flag,&amp;lb_flag,&amp;rb_flag,&amp;tb_flag);
<span style='color:#006e28;'>#else</span>
   update0_(f_t_np1,f_t_n,f_np1,f_n,&amp;Nx,&amp;Ny,&amp;dt,&amp;dx,&amp;dy,&amp;bb_flag,&amp;lb_flag,&amp;rb_flag,&amp;tb_flag);
<span style='color:#006e28;'>#endif</span>

   <b>return</b>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// sets excision mask (NO ITERATOR, SO DON'T LOAD POINTERS!!!)</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_fill_ex_mask(real *mask, <span style='color:#0057ae;'>int</span> dim, <span style='color:#0057ae;'>int</span> *shape, real *bbox, real excised)
{
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_fill_bh_bboxes(real *bbox, <span style='color:#0057ae;'>int</span> *num, <span style='color:#0057ae;'>int</span> max_num)
{
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_post_tstep(<span style='color:#0057ae;'>int</span> L)
{
   <b>return</b>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Performs 1 relaxation sweep of the MG equations, and returns an estimate</span>
<span style='color:#898887;'>// of the norm of the residual.</span>
<span style='color:#898887;'>//=============================================================================</span>
real wave_MG_relax(<span style='color:#0057ae;'>void</span>)
{
   <b>return</b> <span style='color:#b08000;'>0</span>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Computes the differential operator L acting on the current grid,</span>
<span style='color:#898887;'>// in a region specified by the grid function &quot;mask&quot;. Stores the result</span>
<span style='color:#898887;'>// in &quot;f_lop&quot; for each MG variable &quot;f&quot;</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_L_op(<span style='color:#0057ae;'>void</span>)
{
   <b>return</b>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Called after calculating the TRE for all variables</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_scale_tre(<span style='color:#0057ae;'>void</span>)
{
   <b>return</b>;
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// post-regrid initialization of constant functions</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> wave_post_regrid(<span style='color:#0057ae;'>void</span>)
{
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>int</span> main(<span style='color:#0057ae;'>int</span> argc, <span style='color:#0057ae;'>char</span> **argv)
{
   amrd(argc,argv,&amp;wave_id,&amp;wave_var_pre_init,
        &amp;wave_var_post_init, &amp;wave_AMRH_var_clear,
        &amp;wave_free_data, &amp;wave_t0_cnst_data,
        &amp;wave_evo_residual, &amp;wave_MG_residual,
        &amp;wave_evolve, &amp;wave_MG_relax, &amp;wave_L_op, 
        &amp;wave_pre_io_calc, &amp;wave_scale_tre, 
        &amp;wave_post_regrid, &amp;wave_post_tstep,
        &amp;wave_fill_ex_mask, &amp;wave_fill_bh_bboxes);
   <b>if</b> (my_rank==<span style='color:#b08000;'>0</span>) elapsed_time();
}

<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#898887;'>// Maintains/reports elapsed wall-clock time.</span>
<span style='color:#898887;'>//=============================================================================</span>
<span style='color:#0057ae;'>void</span> elapsed_time(<span style='color:#0057ae;'>void</span>) {
   <span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span>    first = <span style='color:#b08000;'>1</span>;
   <b>struct</b>        timeb t;
   <span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>double</span> msinit;
   <span style='color:#0057ae;'>double</span>        mscurr, mselapsed;

   ftime(&amp;t);
   mscurr = <span style='color:#b08000;'>1000.0</span> * t.time + t.millitm;
   <b>if</b>( first ) {
      msinit = mscurr;
      first = <span style='color:#b08000;'>0</span>;
   }
	mselapsed = mscurr - msinit;
   printf(<span style='color:#bf0303;'>&quot;elapsed_time: Seconds since initial call: %12.3f</span><span style='color:#924c9d;'>\n</span><span style='color:#bf0303;'>&quot;</span>,
         mselapsed / <span style='color:#b08000;'>1000.0</span>);
}
</pre>

		      <div style="clear: both;"></div>
	         </div>
		      <hr />
	         <div class ="date">last update:   , </div>
	    <div class="footer">
           <p><a href="Home.html">Home</a>|<a href="Research.html">Research</a>|<a href="Contact.html">Contact</a>|<a href="Links.html">Links</a>|<a href="Misc.html">Misc</a>|<a href="sg">Template</a></p>

      </div>  
	    <div style="clear: both;">&nbsp;</div>
        </div> <!-- end content -->
	<!-- in class postandside -->

                 <!--in class postandside-->   
         <!--this line is for compatibility issues --><div style="clear: both;">&#160;</div> <!--Displacement --> 
     </div> <!--End of post and side -->

     <!-- in class page2 -->
     <div style="clear: both;">&nbsp;</div>
  </div> <!--End of Page2 -->
     <div style="clear: both;">&nbsp;</div>

</div> <!-- End of page -->
<!--this is end of the file -->
<!-- ~~~ This content is generated using sg web template ~~-->
<!-- ~~~ For more information visit: http://laplace.physics.ubc.ca/People/arman/sg ~~ -->
</body>
</html>
