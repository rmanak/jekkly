<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="c">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Comment { color: #8080ff; font-weight: bold; }
.Constant { color: #ff6060; }
.Special { color: #ff40ff; }
.Statement { color: #aacc00; }
.PreProc { color: #ff40ff; }
.Type { color: #00ff00; }
-->
</style>

<pre id='vimCodeElement'>
<span class="Comment">/*</span><span class="Comment"> AAK:</span>
<span class="Comment"> * Utility to merge sdf files generated by PAMR</span>
<span class="Comment"> * Assumes that the sdf files will cover a box region</span>
<span class="Comment"> </span><span class="Comment">*/</span>


<span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;bbhutil.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sdfmerge.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;iv.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;dv.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;</span>

<span class="PreProc">#define max_sdf_file </span><span class="Constant">1024</span>
<span class="PreProc">#define max_dim </span><span class="Constant">3</span>
<span class="PreProc">#define max_fname_size </span><span class="Constant">256</span>
<span class="PreProc">#define max_name_size </span><span class="Constant">64</span>
<span class="PreProc">#define m_inf -</span><span class="Constant">1.0E25</span>
<span class="PreProc">#define p_inf </span><span class="Constant">1.0E25</span>

<span class="Type">double</span> round(<span class="Type">double</span> x);


<span class="Type">struct</span> my_SDF {
   <span class="Type">char</span> file[max_fname_size];
   <span class="Type">char</span> name[max_name_size];
   <span class="Type">char</span> **cnames;
   <span class="Type">int</span> dim;
   <span class="Type">int</span> size;
   <span class="Type">int</span> coord_size;
   <span class="Type">int</span> shape[max_dim];
   <span class="Type">double</span> bbox[max_dim*<span class="Constant">2</span>];
   <span class="Type">double</span> *data;
   <span class="Type">double</span> *coords;
   <span class="Type">int</span> position[max_dim];
} ;

<span class="Type">typedef</span> <span class="Type">struct</span> my_SDF SDF;

<span class="Type">int</span> main(<span class="Type">int</span> argc, <span class="Type">char</span> *argv[]) {

   SDF gf[max_sdf_file];
   <span class="Type">int</span> num_sdf_files;
   <span class="Type">int</span> i, j, k, l;
   <span class="Type">int</span> lev;
   <span class="Type">double</span> time;
   <span class="Type">int</span> crd_pty;
   <span class="Type">int</span> debug = <span class="Constant">0</span>;
   <span class="Type">int</span> check_compatibility = <span class="Constant">1</span>;
   <span class="Type">double</span> bbox[max_dim*<span class="Constant">2</span>];
   <span class="Type">int</span> shape[max_dim];
   <span class="Type">double</span> dx[max_dim];
   <span class="Type">int</span> size;
   <span class="Type">double</span> *data;
   <span class="Type">int</span> dim;
   <span class="Type">int</span> rc;
   <span class="Type">int</span> count;
   <span class="Type">int</span> trace = <span class="Constant">1</span>;


   num_sdf_files = argc;
   lev = <span class="Constant">1</span>;

   <span class="Statement">for</span>(i=<span class="Constant">0</span>;i&lt;max_dim;i++) {
      bbox[<span class="Constant">2</span>*i] = p_inf;
      bbox[<span class="Constant">2</span>*i+<span class="Constant">1</span>] = m_inf;
      shape[i] = <span class="Constant">0</span>;
   }

   <span class="Statement">for</span>(i=<span class="Constant">1</span>;i&lt;num_sdf_files;i++) {

      strcpy(gf[i].file,argv[i]);

      printf(<span class="Constant">&quot;reading rank</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
      gft_read_rank(gf[i].file,lev,&amp;gf[i].dim);
      printf(<span class="Constant">&quot;done!</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

      ivls(gf[i].shape,<span class="Constant">1</span>,max_dim);

      printf(<span class="Constant">&quot;reading shape</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
      gft_read_shape(gf[i].file,lev,gf[i].shape);

      printf(<span class="Constant">&quot;reading name</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
      gft_read_name(gf[i].file,<span class="Constant">1</span>,gf[i].name);

      gf[i].coord_size = <span class="Constant">0</span>;
      gf[i].size = <span class="Constant">1</span>;

      printf(<span class="Constant">&quot;some calc...</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
      <span class="Statement">for</span>( j=<span class="Constant">0</span>; j&lt;gf[i].dim; j++ ) {
         gf[i].coord_size += gf[i].shape[j];
         gf[i].size *= gf[i].shape[j];
      }

      printf(<span class="Constant">&quot;allocating memory</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
      gf[i].coords = vec_alloc(gf[i].coord_size);
      gf[i].data = vec_alloc(gf[i].size);

      gf[i].cnames=(<span class="Type">char</span> **)malloc(<span class="Constant">1</span>*<span class="Statement">sizeof</span>(<span class="Type">char</span> *));
      gf[i].cnames[<span class="Constant">0</span>] = (<span class="Type">char</span> *)malloc(<span class="Constant">6</span>*<span class="Statement">sizeof</span>(<span class="Type">char</span>));


      <span class="Statement">if</span> (trace == <span class="Constant">1</span>) {
        printf(<span class="Constant">&quot;reading </span><span class="Special">%s</span><span class="Constant"> file...</span><span class="Special">\n</span><span class="Constant">&quot;</span>,gf[i].file);
      }
      gft_read_full( gf[i].file,lev,gf[i].shape,gf[i].cnames[<span class="Constant">0</span>],gf[i].dim,
            &amp;time, gf[i].coords, gf[i].data);
      <span class="Statement">if</span> (trace == <span class="Constant">1</span>) {
        printf(<span class="Constant">&quot;done!</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
      }

      gf[i].bbox[<span class="Constant">0</span>] = gf[i].coords[<span class="Constant">0</span>];
      gf[i].bbox[<span class="Constant">1</span>] = gf[i].coords[gf[i].shape[<span class="Constant">0</span>]-<span class="Constant">1</span>];

      crd_pty = <span class="Constant">0</span>;

      <span class="Statement">for</span>(j=<span class="Constant">0</span>;j&lt;gf[i].dim;j++) {
         gf[i].bbox[j*<span class="Constant">2</span>] =  gf[i].coords[crd_pty];
         gf[i].bbox[j*<span class="Constant">2</span>+<span class="Constant">1</span>] = gf[i].coords[crd_pty+gf[i].shape[j]-<span class="Constant">1</span>];
         crd_pty += gf[i].shape[j];
      }

      <span class="Statement">for</span>(j=<span class="Constant">0</span>;j&lt;gf[<span class="Constant">1</span>].dim;j++) {
         <span class="Statement">if</span> (gf[i].bbox[<span class="Constant">2</span>*j] &lt; bbox[<span class="Constant">2</span>*j]) { bbox[<span class="Constant">2</span>*j] = gf[i].bbox[<span class="Constant">2</span>*j]; }
         <span class="Statement">if</span> (gf[i].bbox[<span class="Constant">2</span>*j+<span class="Constant">1</span>] &gt; bbox[<span class="Constant">2</span>*j+<span class="Constant">1</span>] ) { bbox[<span class="Constant">2</span>*j+<span class="Constant">1</span>] = gf[i].bbox[<span class="Constant">2</span>*j+<span class="Constant">1</span>]; }
      }


   <span class="Statement">if</span> (trace == <span class="Constant">1</span>) {
   }
   } <span class="Comment">//End of loop over all grid functions</span>


   size = <span class="Constant">1</span>;
   dim = gf[<span class="Constant">1</span>].dim;

   ivls(shape,<span class="Constant">1</span>,max_dim);
   <span class="Statement">for</span>(i=<span class="Constant">0</span>;i&lt;dim;i++) {
      dx[i] = (gf[<span class="Constant">1</span>].bbox[<span class="Constant">2</span>*i+<span class="Constant">1</span>]-gf[<span class="Constant">1</span>].bbox[<span class="Constant">2</span>*i] ) / (gf[<span class="Constant">1</span>].shape[i] - <span class="Constant">1</span>);
      shape[i] = (<span class="Type">int</span>)round(( bbox[<span class="Constant">2</span>*i+<span class="Constant">1</span>] - bbox[<span class="Constant">2</span>*i] ) / dx[i] ) + <span class="Constant">1</span>;
      size *= shape[i];
   }

   data = vec_alloc(size);
   dvls(data,<span class="Constant">0.0</span>,size);

   <span class="Statement">for</span> (i=<span class="Constant">1</span>;i&lt;num_sdf_files;i++) {
      ivls(gf[i].position,<span class="Constant">0</span>,max_dim);
      <span class="Statement">for</span>(j=<span class="Constant">0</span>;j&lt;dim;j++) {
         gf[i].position[j] = (<span class="Type">int</span>)round( (gf[i].bbox[<span class="Constant">2</span>*j] - bbox[<span class="Constant">2</span>*j]) / dx[j] );
      }
   } <span class="Comment">//End of loop over all grid functions</span>

   lev = <span class="Constant">1</span>;
   rc = <span class="Constant">1</span>;
   <span class="Statement">while</span> (rc == <span class="Constant">1</span>) {

      count = <span class="Constant">0</span>;
      <span class="Statement">for</span> (i=<span class="Constant">1</span>;i&lt;num_sdf_files;i++){
           rc = gft_read_full( gf[i].file,lev,gf[i].shape,gf[i].cnames[<span class="Constant">0</span>],gf[i].dim,
            &amp;time, gf[i].coords, gf[i].data);
           <span class="Statement">if</span> (rc == <span class="Constant">1</span>) {
             count++;
             inj_grid_func_(data,gf[i].data,shape,gf[i].shape,gf[i].position,&amp;dim);
           }
      }

      <span class="Statement">if</span> ((rc == <span class="Constant">1</span>) &amp;&amp; (count !=num_sdf_files-<span class="Constant">1</span>)) {
         printf(<span class="Constant">&quot;Could not read one of the sdf files at lev:</span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,lev);
         exit (<span class="Constant">1</span>);
      }
      <span class="Statement">else</span> <span class="Statement">if</span> (rc == <span class="Constant">1</span>) {
         <span class="Statement">if</span> (trace == <span class="Constant">1</span>) {
           printf(<span class="Constant">&quot;Output at time </span><span class="Special">%f</span><span class="Constant">, lev </span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">\n</span><span class="Constant">&quot;</span>,time,lev);
         }
         gft_out_bbox(<span class="Constant">&quot;merged.sdf&quot;</span>,time,shape,dim,bbox,data);
         lev++;
      }

   } <span class="Comment">//END OF WHILE POSSIBLE TO READ</span>

   printf(<span class="Constant">&quot;sdf files merged to &gt; merged.sdf upto level: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,lev-<span class="Constant">1</span>);

   gft_close_all();

} <span class="Comment">//END OF MAIN</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
