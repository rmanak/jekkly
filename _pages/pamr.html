<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="description" />
<meta name="keywords" content="keywords" />
<meta name="author" content="author" />
<link rel="stylesheet" type="text/css" href="pagestyle.css" />
<title>Arman Akbarian's Homepage</title>
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>
<div class="page">
  <div class="page2">
     <div style="width:100%;height:1px;font-family: Tahoma; font-size: 1pt;"></div>
     <div  class ="header">
		
	     <div class="title">

			Arman Akbarian
			<div class="subtitle">UNIVERSITY OF BRITISH COLUMBIA <br /> PHYSICS &amp; ASTRONOMY DEPT. </div>
	</div> <!-- End of title -->
		<div class="sidebar">
         	<div class="sider">
               <p><a href="Home.html">Home <img src="img/home.svg" width="11px" /></a>
<a href="Research.html">Research <img src="img/beaker.svg" width="11px" /></a>
<a href="Publications.html">Publications <img src="img/pencil.svg" width="11px" /></a>
<a target="_blank" href="http://laplace.phas.ubc.ca/">Group Page <img style="margin-left:1px;" src="img/external-link.svg" alt="" align="bottom" /> <img src="img/people.svg" width="11px" /></a>
<a href="Contact.html">Contact <img src="img/envelope-closed.svg" width="11px" /></a>
<a href="CV.html">CV <img src="img/person.svg" width="11px" /></a></p>

<hr />

<p><a href="Links.html">Links <img src="img/link.svg" width="11px" /></a>
<a href="Learn-By-Examples.html">Programming <img src="img/code.svg" width="11px"/></a>
<a target="_blank" href="FD_doc">FD Toolkit <img style="margin-left:1px;" src="img/external-link.svg" alt="" align="bottom" /> <img src="img/graph.svg" width="11px" /></a>
<a target="_blank" href="sg">Web Template <img style="margin-left:1px;" src="img/external-link.svg" alt="" align="bottom" /> <img src="img/globe.svg" width="11px" /></a>
<a href="http://rmanak.github.io/notes">Miscellany <img src="img/layers.svg" width="11px" /></a></p>

             </div>
         </div> <!--End of Sidebar -->


     </div> <!-- end header -->
	
     <!--This line is for future use -->   <div style="text-align:center; padding-top:10px; padding-bottom:10px;"></div>
	      
     <!--This line is for compatibility issues --> <div style="width:100%;height:5px;font-family: Tahoma; font-size: 1pt;"></div>
     <!--in class page2 -->
     <div class="postandside">
		        <div class="content">
            <div class="post">
              
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// application interface functions for wave example</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// PAMR example to solve 2D wave equation</font><br>
<font color="#0000ff">// See <a href="http://laplace.physics.ubc.ca/People/arman/file/wave2d_pamr.tar.gz">http://laplace.physics.ubc.ca/People/arman/file/wave2d_pamr.tar.gz</a> for source</font><br>
<br>
<font color="#a020f0">#include </font><font color="#ff00ff">&lt;stdlib.h&gt;</font><br>
<font color="#a020f0">#include </font><font color="#ff00ff">&lt;stdio.h&gt;</font><br>
<font color="#a020f0">#include </font><font color="#ff00ff">&lt;pamr.h&gt;</font><br>
<font color="#a020f0">#include </font><font color="#ff00ff">&lt;amrd.h&gt;</font><br>
<font color="#a020f0">#include </font><font color="#ff00ff">&lt;math.h&gt;</font><br>
<font color="#a020f0">#include </font><font color="#ff00ff">&lt;mpi.h&gt;</font><br>
<font color="#a020f0">#include </font><font color="#ff00ff">&quot;wave.h&quot;</font><br>
<br>
<font color="#a020f0">#include </font><font color="#ff00ff">&lt;sys/timeb.h&gt;</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;elapsed_time(<font color="#2e8b57"><b>void</b></font>);<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// id parameters (time symmetric gaussian)</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<br>
<font color="#0000ff">//Initialization parameters:</font><br>
real amp, tdam, xc, xwid, yc, ywid;<br>
<font color="#0000ff">//=====================================</font><br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// some convenient, &quot;local&quot; global variables</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<br>
<font color="#0000ff">//The pointers to actual grid function data:</font><br>
real *f_t_n, *f_t_np1, *f_n, *f_np1;<br>
<font color="#0000ff">//=======================================</font><br>
<br>
<font color="#0000ff">//The pointers to grid:</font><br>
real *x, *y;<br>
<font color="#0000ff">//===========================</font><br>
<br>
<font color="#0000ff">//Parameters that describe the grid:</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;shape[<font color="#ff00ff">2</font>]; <font color="#0000ff">// number of grid points in each dim, basically shape[0]=Nx, shape[1]=Ny</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;ghost_width[<font color="#ff00ff">4</font>]; <font color="#0000ff">//side of ghost cells, 2*dim array, at x_min, x_max, y_min and so on</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;Nx,Ny;<br>
<font color="#2e8b57"><b>int</b></font>&nbsp;phys_bdy[<font color="#ff00ff">4</font>]; <font color="#0000ff">// 1 or 0, wether or not boundary is physical, has size = dim*2</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;lb_flag,rb_flag,tb_flag,bb_flag; <font color="#0000ff">//convenient variable for phys boundary indication</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;size; <font color="#0000ff">//size=Nx*Ny*...</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;dim; <font color="#0000ff">//the spatial dimension of the grid (only 1,2 or 3)</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;g_rank; <font color="#0000ff">// To store the MPI rank of the execution</font><br>
<br>
real base_bbox[<font color="#ff00ff">4</font>], bbox[<font color="#ff00ff">4</font>], dx, dy, dt; <br>
<font color="#0000ff">// bbox stores the coordinate bounding box [x1,x2,y1...]</font><br>
<font color="#0000ff">// base_bbox is the coordinate of the entire domain</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;g_L; <font color="#0000ff">//to store the grid level (in AMR heirarchy)</font><br>
<br>
<br>
<font color="#0000ff">//To store the grid function numbers, see set_gfns subroutine</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;f_t_n_gfn, f_t_np1_gfn, f_n_gfn, f_np1_gfn;<br>
<font color="#0000ff">//===========</font><br>
<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// call after variables have been defined</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;set_gfns(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a52a2a"><b>if</b></font>&nbsp;((f_t_np1_gfn = PAMR_get_gfn(<font color="#ff00ff">&quot;f_t&quot;</font>,PAMR_AMRH,<font color="#ff00ff">1</font>))&lt;<font color="#ff00ff">0</font>) AMRD_stop(<font color="#ff00ff">&quot;set_gnfs error&quot;</font>,<font color="#ff00ff">0</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a52a2a"><b>if</b></font>&nbsp;((f_t_n_gfn&nbsp;&nbsp; = PAMR_get_gfn(<font color="#ff00ff">&quot;f_t&quot;</font>,PAMR_AMRH,<font color="#ff00ff">2</font>))&lt;<font color="#ff00ff">0</font>) AMRD_stop(<font color="#ff00ff">&quot;set_gnfs error&quot;</font>,<font color="#ff00ff">0</font>);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a52a2a"><b>if</b></font>&nbsp;((f_np1_gfn&nbsp;&nbsp; = PAMR_get_gfn(<font color="#ff00ff">&quot;f&quot;</font>,PAMR_AMRH,<font color="#ff00ff">1</font>))&lt;<font color="#ff00ff">0</font>) AMRD_stop(<font color="#ff00ff">&quot;set_gnfs error&quot;</font>,<font color="#ff00ff">0</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a52a2a"><b>if</b></font>&nbsp;((f_n_gfn&nbsp;&nbsp;&nbsp;&nbsp; = PAMR_get_gfn(<font color="#ff00ff">&quot;f&quot;</font>,PAMR_AMRH,<font color="#ff00ff">2</font>))&lt;<font color="#ff00ff">0</font>) AMRD_stop(<font color="#ff00ff">&quot;set_gnfs error&quot;</font>,<font color="#ff00ff">0</font>);<br>
<br>
<font color="#0000ff">// get_gfn returns the grid function number:</font><br>
<font color="#0000ff">// PAMR_get_gfn(A,B,C) </font><br>
<font color="#0000ff">// A &gt;&gt; grid function name</font><br>
<font color="#0000ff">// B &gt;&gt; in which heirarchy, two options: PAMR_AMRH: AMR heirarchy, PAMR_MGH: multigrid h.</font><br>
<font color="#0000ff">// C &gt;&gt; time level if it is in AMRH, else 0, latest time ordered first.</font><br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// call with valid iter to set up globals:</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;ldptr(<font color="#2e8b57"><b>void</b></font>) <br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp; real dx0[<font color="#ff00ff">2</font>];<br>
&nbsp;&nbsp;&nbsp;&nbsp; real *x0[<font color="#ff00ff">2</font>]; <font color="#0000ff">//array of size dim, pointing to local perimeter coordinate array</font><br>
&nbsp;&nbsp;&nbsp;&nbsp; real *gfs[PAMR_MAX_GFNS]; <font color="#0000ff">//array of size ngfs, pointers to local data array</font><br>
&nbsp;&nbsp; <font color="#2e8b57"><b>static</b></font>&nbsp;<font color="#2e8b57"><b>int</b></font>&nbsp;first=<font color="#ff00ff">1</font>;<br>
<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>if</b></font>&nbsp;(first) <br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first=<font color="#ff00ff">0</font>; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_gfns();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PAMR_get_global_bbox(base_bbox); <font color="#0000ff">//AAK??</font><br>
&nbsp;&nbsp; }<br>
<font color="#0000ff">//These are to get the information of the grid</font><br>
&nbsp;&nbsp; PAMR_get_g_dim(&amp;dim); <font color="#0000ff">//saves the dimension of the grid in dim</font><br>
&nbsp;&nbsp; PAMR_get_g_rank(&amp;g_rank); <font color="#0000ff">// gets the MPI rank</font><br>
&nbsp;&nbsp; PAMR_get_g_shape(shape); <font color="#0000ff">//gets the shape (Nx,Ny...)</font><br>
&nbsp;&nbsp; PAMR_get_g_bbox(bbox); <font color="#0000ff">//gets the boundary (x1,x2,y1,y2...)</font><br>
&nbsp;&nbsp; PAMR_get_g_ghost_width(ghost_width); <font color="#0000ff">//gets the ghots width at boundaries</font><br>
&nbsp;&nbsp; PAMR_get_g_level(&amp;g_L); <font color="#0000ff">// gets the level number of the current grid</font><br>
&nbsp;&nbsp; PAMR_get_dxdt(g_L,dx0,&amp;dt); <font color="#0000ff">//clear</font><br>
&nbsp;&nbsp; dx=dx0[<font color="#ff00ff">0</font>]; <font color="#0000ff">//convenient variables??</font><br>
&nbsp;&nbsp; dy=dx0[<font color="#ff00ff">1</font>];<br>
<br>
<font color="#0000ff">//AAK: This is for finding the real boundary</font><br>
&nbsp;&nbsp; <font color="#a52a2a"><b>if</b></font>&nbsp;((bbox[<font color="#ff00ff">0</font>]-base_bbox[<font color="#ff00ff">0</font>])&lt;dx/<font color="#ff00ff">2</font>) phys_bdy[<font color="#ff00ff">0</font>]=<font color="#ff00ff">1</font>; <font color="#a52a2a"><b>else</b></font>&nbsp;phys_bdy[<font color="#ff00ff">0</font>]=<font color="#ff00ff">0</font>;<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>if</b></font>&nbsp;((base_bbox[<font color="#ff00ff">1</font>]-bbox[<font color="#ff00ff">1</font>])&lt;dx/<font color="#ff00ff">2</font>) phys_bdy[<font color="#ff00ff">1</font>]=<font color="#ff00ff">1</font>; <font color="#a52a2a"><b>else</b></font>&nbsp;phys_bdy[<font color="#ff00ff">1</font>]=<font color="#ff00ff">0</font>;<br>
&nbsp;&nbsp; Nx=shape[<font color="#ff00ff">0</font>];<br>
<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>if</b></font>&nbsp;((bbox[<font color="#ff00ff">2</font>]-base_bbox[<font color="#ff00ff">2</font>])&lt;dy/<font color="#ff00ff">2</font>) phys_bdy[<font color="#ff00ff">2</font>]=<font color="#ff00ff">1</font>; <font color="#a52a2a"><b>else</b></font>&nbsp;phys_bdy[<font color="#ff00ff">2</font>]=<font color="#ff00ff">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a52a2a"><b>if</b></font>&nbsp;((base_bbox[<font color="#ff00ff">3</font>]-bbox[<font color="#ff00ff">3</font>])&lt;dy/<font color="#ff00ff">2</font>) phys_bdy[<font color="#ff00ff">3</font>]=<font color="#ff00ff">1</font>; <font color="#a52a2a"><b>else</b></font>&nbsp;phys_bdy[<font color="#ff00ff">3</font>]=<font color="#ff00ff">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ny=shape[<font color="#ff00ff">1</font>];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size=Nx*Ny;<br>
<br>
&nbsp;&nbsp; <font color="#0000ff">//setting the convenient variables</font><br>
&nbsp;&nbsp; lb_flag = phys_bdy[<font color="#ff00ff">0</font>];<br>
&nbsp;&nbsp; rb_flag = phys_bdy[<font color="#ff00ff">1</font>];<br>
&nbsp;&nbsp; bb_flag = phys_bdy[<font color="#ff00ff">2</font>];<br>
&nbsp;&nbsp; tb_flag = phys_bdy[<font color="#ff00ff">3</font>];<br>
<font color="#0000ff">//=========================</font><br>
&nbsp;&nbsp; PAMR_get_g_x(x0); <font color="#0000ff">//gets the pointer to the coordinate array</font><br>
<br>
&nbsp;&nbsp; x=x0[<font color="#ff00ff">0</font>]; <font color="#0000ff">//the pointers to the array of actual grid data (size Nx*Ny..)</font><br>
&nbsp;&nbsp; y=x0[<font color="#ff00ff">1</font>]; <br>
<br>
&nbsp;&nbsp; PAMR_get_g_gfs(gfs); <font color="#0000ff">//gets the pointer to local data of grid function</font><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">//AAK:store the pointer in convenient variables</font><br>
&nbsp;&nbsp;&nbsp;&nbsp; f_n&nbsp;&nbsp;&nbsp;&nbsp; = gfs[f_n_gfn-<font color="#ff00ff">1</font>]; <font color="#0000ff">//AAK?? what is -1, numbering starts from&nbsp;&nbsp;1?</font><br>
&nbsp;&nbsp;&nbsp;&nbsp; f_np1&nbsp;&nbsp; = gfs[f_np1_gfn-<font color="#ff00ff">1</font>];<br>
&nbsp;&nbsp;&nbsp;&nbsp; f_t_n&nbsp;&nbsp; = gfs[f_t_n_gfn-<font color="#ff00ff">1</font>];<br>
&nbsp;&nbsp;&nbsp;&nbsp; f_t_np1 = gfs[f_t_np1_gfn-<font color="#ff00ff">1</font>];<br>
<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// utility routines</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;const_f(real *f, real c)<br>
{<br>
&nbsp;&nbsp; <font color="#2e8b57"><b>int</b></font>&nbsp;i;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#a52a2a"><b>for</b></font>&nbsp;(i=<font color="#ff00ff">0</font>; i&lt;Nx*Ny; i++) f[i]=c;<br>
}<br>
<br>
<font color="#2e8b57"><b>void</b></font>&nbsp;zero(real *f)<br>
{<br>
&nbsp;&nbsp; const_f(f,<font color="#ff00ff">0</font>);<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Routines required by amrd:</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Returns 0 to use default mechanism, or is expected to calculate</font><br>
<font color="#0000ff">// the correct initial hierarchy and return 1:</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;wave_id(<font color="#2e8b57"><b>void</b></font>) <br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>if</b></font>( my_rank == <font color="#ff00ff">0</font>&nbsp;) elapsed_time();<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>&nbsp;<font color="#ff00ff">0</font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Sets custom parameters, variables, etc. Split up into two segments,</font><br>
<font color="#0000ff">// one called before the pamr context is initialized and standard</font><br>
<font color="#0000ff">// parameters are read, and the other afterwards</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_var_pre_init(<font color="#2e8b57"><b>char</b></font>&nbsp;*pfile)<br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}<br>
<br>
<br>
<font color="#0000ff">//AAK: one of the hook functions passed to amrd, to read the parameters from file</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_var_post_init(<font color="#2e8b57"><b>char</b></font>&nbsp;*pfile)<br>
{<br>
&nbsp;&nbsp; <font color="#2e8b57"><b>int</b></font>&nbsp;i,j;<br>
&nbsp;&nbsp; <font color="#2e8b57"><b>char</b></font>&nbsp;buf[<font color="#ff00ff">64</font>]; <font color="#0000ff">//AAK??</font><br>
<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>if</b></font>&nbsp;(my_rank==<font color="#ff00ff">0</font>)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;system(<font color="#ff00ff">&quot;date &gt; date.dat&quot;</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<font color="#ff00ff">&quot;===================================================================</font><font color="#6a5acd">\n</font><font color="#ff00ff">&quot;</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<font color="#ff00ff">&quot;Reading wave parameters:</font><font color="#6a5acd">\n\n</font><font color="#ff00ff">&quot;</font>);<br>
&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; amp=tdam=xc=yc=<font color="#ff00ff">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp; xwid=ywid=<font color="#ff00ff">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">//AAK: the file is in RNPL format</font><br>
&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">// last argument is the size of the array, 1 for just a real number</font><br>
&nbsp;&nbsp; AMRD_real_param(pfile,<font color="#ff00ff">&quot;amp&quot;</font>,&amp;amp,<font color="#ff00ff">1</font>);<br>
&nbsp;&nbsp; AMRD_real_param(pfile,<font color="#ff00ff">&quot;tdam&quot;</font>,&amp;tdam,<font color="#ff00ff">1</font>);<br>
&nbsp;&nbsp; AMRD_real_param(pfile,<font color="#ff00ff">&quot;xc&quot;</font>,&amp;xc,<font color="#ff00ff">1</font>);<br>
&nbsp;&nbsp; AMRD_real_param(pfile,<font color="#ff00ff">&quot;yc&quot;</font>,&amp;yc,<font color="#ff00ff">1</font>);<br>
&nbsp;&nbsp; AMRD_real_param(pfile,<font color="#ff00ff">&quot;xwid&quot;</font>,&amp;xwid,<font color="#ff00ff">1</font>);<br>
&nbsp;&nbsp; AMRD_real_param(pfile,<font color="#ff00ff">&quot;ywid&quot;</font>,&amp;ywid,<font color="#ff00ff">1</font>);<br>
&nbsp;&nbsp; <br>
<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>if</b></font>&nbsp;(my_rank==<font color="#ff00ff">0</font>) printf(<font color="#ff00ff">&quot;===================================================================</font><font color="#6a5acd">\n</font><font color="#ff00ff">&quot;</font>);<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Sets all t=n variables to their 'zero' values:</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_AMRH_var_clear(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;ldptr();<br>
<br>
<font color="#0000ff">//&nbsp;&nbsp; zero(phi_n); </font><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; zero(f_n);<br>
&nbsp;&nbsp;&nbsp;&nbsp; zero(f_t_n);<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Initial data for free fields: (at tn=2)</font><br>
<font color="#0000ff">//</font><br>
<font color="#0000ff">// currently, we only allow for time-symmetric initial data</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_free_data(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp; ldptr();<br>
<font color="#0000ff">//This initializes the grid, all the calculations are encapsulated in the routine.</font><br>
&nbsp;&nbsp;&nbsp;&nbsp; initializer0_(f_t_n,f_n,&amp;Nx,&amp;Ny,x,y,&amp;amp,&amp;tdam,&amp;xc,&amp;xwid,&amp;yc,&amp;ywid);<br>
<br>
<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}&nbsp;&nbsp;<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Initial constraint data --- called after each MG iteration.</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_t0_cnst_data(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Calculations prior to saving info to disk.</font><br>
<font color="#0000ff">//</font><br>
<font color="#0000ff">// NOTE: at this point, the time sequence is: n,nm1,np1</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_pre_io_calc(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Returns some norm of the residual for the evolution variables,</font><br>
<font color="#0000ff">// called after an evolution iteration.</font><br>
<font color="#0000ff">// We're using an explicit scheme to solve for phi, hence return 0</font><br>
<font color="#0000ff">//=============================================================================</font><br>
real wave_evo_residual(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>&nbsp;<font color="#ff00ff">0</font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Returns some norm of the residual for the MG variables, *AND* </font><br>
<font color="#0000ff">// stores the point-wise residual in &quot;f_res&quot; for each MG variable &quot;f&quot; (for</font><br>
<font color="#0000ff">// computing new RHS's)</font><br>
<font color="#0000ff">//=============================================================================</font><br>
real wave_MG_residual(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>&nbsp;<font color="#ff00ff">0</font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Performs 1 iteration of the evolution equations </font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_evolve(<font color="#2e8b57"><b>int</b></font>&nbsp;iter)<br>
{<br>
&nbsp;&nbsp; ldptr();<br>
<font color="#0000ff">//This updates the grid, all the calculations are encapsulated in the routine</font><br>
<font color="#a020f0">#ifdef __L </font><br>
&nbsp;&nbsp;&nbsp;&nbsp;update0__(f_t_np1,f_t_n,f_np1,f_n,&amp;Nx,&amp;Ny,&amp;dt,&amp;dx,&amp;dy,&amp;bb_flag,&amp;lb_flag,&amp;rb_flag,&amp;tb_flag);<br>
<font color="#a020f0">#else</font><br>
&nbsp;&nbsp; update0_(f_t_np1,f_t_n,f_np1,f_n,&amp;Nx,&amp;Ny,&amp;dt,&amp;dx,&amp;dy,&amp;bb_flag,&amp;lb_flag,&amp;rb_flag,&amp;tb_flag);<br>
<font color="#a020f0">#endif</font><br>
<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// sets excision mask (NO ITERATOR, SO DON'T LOAD POINTERS!!!)</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_fill_ex_mask(real *mask, <font color="#2e8b57"><b>int</b></font>&nbsp;dim, <font color="#2e8b57"><b>int</b></font>&nbsp;*shape, real *bbox, real excised)<br>
{<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_fill_bh_bboxes(real *bbox, <font color="#2e8b57"><b>int</b></font>&nbsp;*num, <font color="#2e8b57"><b>int</b></font>&nbsp;max_num)<br>
{<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_post_tstep(<font color="#2e8b57"><b>int</b></font>&nbsp;L)<br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Performs 1 relaxation sweep of the MG equations, and returns an estimate</font><br>
<font color="#0000ff">// of the norm of the residual.</font><br>
<font color="#0000ff">//=============================================================================</font><br>
real wave_MG_relax(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>&nbsp;<font color="#ff00ff">0</font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Computes the differential operator L acting on the current grid,</font><br>
<font color="#0000ff">// in a region specified by the grid function &quot;mask&quot;. Stores the result</font><br>
<font color="#0000ff">// in &quot;f_lop&quot; for each MG variable &quot;f&quot;</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_L_op(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Called after calculating the TRE for all variables</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_scale_tre(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>return</b></font>;<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// post-regrid initialization of constant functions</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;wave_post_regrid(<font color="#2e8b57"><b>void</b></font>)<br>
{<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>int</b></font>&nbsp;main(<font color="#2e8b57"><b>int</b></font>&nbsp;argc, <font color="#2e8b57"><b>char</b></font>&nbsp;**argv)<br>
{<br>
&nbsp;&nbsp; amrd(argc,argv,&amp;wave_id,&amp;wave_var_pre_init,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;wave_var_post_init, &amp;wave_AMRH_var_clear,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;wave_free_data, &amp;wave_t0_cnst_data,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;wave_evo_residual, &amp;wave_MG_residual,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;wave_evolve, &amp;wave_MG_relax, &amp;wave_L_op, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;wave_pre_io_calc, &amp;wave_scale_tre, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;wave_post_regrid, &amp;wave_post_tstep,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;wave_fill_ex_mask, &amp;wave_fill_bh_bboxes);<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>if</b></font>&nbsp;(my_rank==<font color="#ff00ff">0</font>) elapsed_time();<br>
}<br>
<br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#0000ff">// Maintains/reports elapsed wall-clock time.</font><br>
<font color="#0000ff">//=============================================================================</font><br>
<font color="#2e8b57"><b>void</b></font>&nbsp;elapsed_time(<font color="#2e8b57"><b>void</b></font>) {<br>
&nbsp;&nbsp; <font color="#2e8b57"><b>static</b></font>&nbsp;<font color="#2e8b57"><b>int</b></font>&nbsp;&nbsp;&nbsp;&nbsp;first = <font color="#ff00ff">1</font>;<br>
&nbsp;&nbsp; <font color="#2e8b57"><b>struct</b></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeb t;<br>
&nbsp;&nbsp; <font color="#2e8b57"><b>static</b></font>&nbsp;<font color="#2e8b57"><b>double</b></font>&nbsp;msinit;<br>
&nbsp;&nbsp; <font color="#2e8b57"><b>double</b></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mscurr, mselapsed;<br>
<br>
&nbsp;&nbsp; ftime(&amp;t);<br>
&nbsp;&nbsp; mscurr = <font color="#ff00ff">1000.0</font>&nbsp;* t.time + t.millitm;<br>
&nbsp;&nbsp; <font color="#a52a2a"><b>if</b></font>( first ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msinit = mscurr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first = <font color="#ff00ff">0</font>;<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; mselapsed = mscurr - msinit;<br>
&nbsp;&nbsp; printf(<font color="#ff00ff">&quot;elapsed_time: Seconds since initial call: </font><font color="#6a5acd">%12.3f</font><font color="#6a5acd">\n</font><font color="#ff00ff">&quot;</font>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mselapsed / <font color="#ff00ff">1000.0</font>);<br>
}<br>
</font>
		      <div style="clear: both;"></div>
	         </div>
		      <hr />
	         <div class ="date">last update:   , </div>
	    <div class="footer">
           <p><a href="Home.html">Home</a>|<a href="Research.html">Research</a>|<a href="Contact.html">Contact</a>|<a href="Links.html">Links</a>|<a href="Misc.html">Misc</a>|<a href="sg">Template</a></p>

      </div>  
	    <div style="clear: both;">&nbsp;</div>
        </div> <!-- end content -->
	<!-- in class postandside -->

                 <!--in class postandside-->   
         <!--this line is for compatibility issues --><div style="clear: both;">&#160;</div> <!--Displacement --> 
     </div> <!--End of post and side -->

     <!-- in class page2 -->
     <div style="clear: both;">&nbsp;</div>
  </div> <!--End of Page2 -->
     <div style="clear: both;">&nbsp;</div>

</div> <!-- End of page -->
<!--this is end of the file -->
<!-- ~~~ This content is generated using sg web template ~~-->
<!-- ~~~ For more information visit: http://laplace.physics.ubc.ca/People/arman/sg ~~ -->
</body>
</html>
